
<!DOCTYPE html>
<html>
<head>
  <title>Bike Route Planner</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .map-container {
      flex: 2;
    }
    .sidebar {
      flex: 1;
      min-width: 300px;
    }
    #map {
      height: 500px;
      width: 100%;
      border: 1px solid #ccc;
    }
    #route-list {
      margin-top: 10px;
      border: 1px solid #ccc;
      padding: 10px;
      background-color: #f9f9f9;
    }
    #error-message {
      color: red;
      margin: 10px 0;
      display: none;
    }
    .route-segment {
      cursor: pointer;
    }
    .segment-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
      border-bottom: 1px solid #ddd;
    }
    .remove-btn {
      background-color: #ff4444;
      color: white;
      border: none;
      padding: 2px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }
    .remove-btn:hover {
      background-color: #cc0000;
    }
    #download-gpx {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
      width: 100%;
    }
    #download-gpx:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    #download-gpx:hover:not(:disabled) {
      background-color: #45a049;
    }
    .segment-tooltip {
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 5px 8px;
      font-size: 12px;
      font-weight: bold;
    }
    .search-container {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    #location-search {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    #search-btn {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #search-btn:hover {
      background-color: #1976D2;
    }
    .leaflet-interactive {
      outline: none !important;
    }
    .leaflet-interactive:focus {
      outline: none !important;
    }
  </style>
</head>
<body>

  <h1>Bike Route Planner</h1>

  <div id="error-message"></div>
  
  <input type="file" id="kml-file" accept=".kml">
  <p style="color: #666; font-size: 14px;">Please upload a KML file to see the available route segments on the map.</p>

  <div class="container">
    <div class="map-container">
      <div id="map"></div>
    </div>
    
    <div class="sidebar">
      <h3>Search Location</h3>
      <div class="search-container">
        <input type="text" id="location-search" placeholder="Enter a place name..." />
        <button id="search-btn">Search</button>
      </div>
      <div id="search-error" style="color: red; font-size: 12px; margin-top: 5px; display: none;"></div>
      
      <h3>Selected Route Segments</h3>
      <div id="route-list">
        <p style="color: #666; font-style: italic;">No segments selected. Click on route segments on the map to add them to your route.</p>
      </div>

      <h3>Route Description</h3>
      <div id="route-description">Click on map segments to build your route.</div>

      <button id="download-gpx" disabled>Download GPX Route</button>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let map;
    let selectedSegments = [];
    let routePolylines = [];

    function initMap() {
      try {
        // Initialize Leaflet map with OpenStreetMap tiles
        map = L.map('map').setView([-19.257753, 146.823688], 2);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Add initial popup message
        const popup = L.popup()
          .setLatLng([-19.257753, 146.823688])
          .setContent('Upload a KML file to see route segments and start planning your bike route.')
          .openOn(map);
        
        // Store reference to close popup later
        window.initialPopup = popup;
        
      } catch (error) {
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'Error loading map: ' + error.message;
      }
    }

    document.getElementById('kml-file').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();

      reader.onload = (e) => {
        try {
          const kmlData = e.target.result;
          const parser = new DOMParser();
          const kml = parser.parseFromString(kmlData, 'application/xml');
          const placemarks = kml.getElementsByTagName('Placemark');

          if (placemarks.length === 0) {
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('error-message').textContent = 'No route segments found in the KML file. Please check if the file contains Placemark elements with coordinates.';
            return;
          }

          // Close the initial popup when KML is successfully loaded
          if (window.initialPopup) {
            map.closePopup(window.initialPopup);
          }
          
          document.getElementById('error-message').style.display = 'none';

          // Clear existing polylines
          routePolylines.forEach(polyline => map.removeLayer(polyline));
          routePolylines = [];

          let bounds = L.latLngBounds();

          for (const placemark of placemarks) {
            const nameElement = placemark.getElementsByTagName('name')[0];
            const coordinatesElement = placemark.getElementsByTagName('coordinates')[0];
            
            if (!nameElement || !coordinatesElement) continue;

            const name = nameElement.textContent;
            const coordinatesStr = coordinatesElement.textContent.trim();
            const coordinates = coordinatesStr.split(/\s+/).map(coordStr => {
              const [lng, lat] = coordStr.split(',').map(parseFloat);
              return [lat, lng]; // Leaflet uses [lat, lng] format
            });

            // Extract original style from KML
            let originalColor = '#FF0000';
            let originalWeight = 3;
            let originalOpacity = 0.8;

            // Check for LineStyle in the placemark
            const lineStyle = placemark.getElementsByTagName('LineStyle')[0];
            if (lineStyle) {
              const colorElement = lineStyle.getElementsByTagName('color')[0];
              const widthElement = lineStyle.getElementsByTagName('width')[0];
              
              if (colorElement) {
                // KML color format is aabbggrr, convert to #rrggbb
                const kmlColor = colorElement.textContent;
                if (kmlColor.length === 8) {
                  const r = kmlColor.substring(6, 8);
                  const g = kmlColor.substring(4, 6);
                  const b = kmlColor.substring(2, 4);
                  originalColor = `#${r}${g}${b}`;
                }
              }
              
              if (widthElement) {
                originalWeight = parseFloat(widthElement.textContent) || 3;
              }
            }

            // Check for Style element with id reference
            const styleUrl = placemark.getElementsByTagName('styleUrl')[0];
            if (styleUrl) {
              const styleId = styleUrl.textContent.replace('#', '');
              const style = kml.querySelector(`Style[id="${styleId}"]`);
              if (style) {
                const lineStyle = style.getElementsByTagName('LineStyle')[0];
                if (lineStyle) {
                  const colorElement = lineStyle.getElementsByTagName('color')[0];
                  const widthElement = lineStyle.getElementsByTagName('width')[0];
                  
                  if (colorElement) {
                    const kmlColor = colorElement.textContent;
                    if (kmlColor.length === 8) {
                      const r = kmlColor.substring(6, 8);
                      const g = kmlColor.substring(4, 6);
                      const b = kmlColor.substring(2, 4);
                      originalColor = `#${r}${g}${b}`;
                    }
                  }
                  
                  if (widthElement) {
                    originalWeight = parseFloat(widthElement.textContent) || 3;
                  }
                }
              }
            }

            // Create polyline for the route segment with original styling
            const polyline = L.polyline(coordinates, {
              color: originalColor,
              weight: originalWeight,
              opacity: originalOpacity,
              className: 'route-segment'
            }).addTo(map);

            // Store segment name and original style for reference
            polyline.segmentName = name;
            polyline.originalStyle = {
              color: originalColor,
              weight: originalWeight,
              opacity: originalOpacity
            };
            routePolylines.push(polyline);

            // Add coordinates to bounds for auto-fitting
            coordinates.forEach(coord => bounds.extend(coord));

            // Add hover effects
            polyline.on('mouseover', function() {
              this.setStyle({
                weight: this.originalStyle.weight + 2,
                opacity: 1
              });
              
              // Create temporary tooltip
              this.bindTooltip(name, {
                permanent: false,
                direction: 'top',
                className: 'segment-tooltip'
              }).openTooltip();
            });

            polyline.on('mouseout', function() {
              if (!selectedSegments.includes(name)) {
                this.setStyle({
                  weight: this.originalStyle.weight,
                  opacity: this.originalStyle.opacity
                });
              }
              this.closeTooltip();
            });

            // Add click event listener
            polyline.on('click', function() {
              if (!selectedSegments.includes(name)) {
                // Add segment to selection
                selectedSegments.push(name);
                this.setStyle({
                  color: '#00ff00',
                  weight: this.originalStyle.weight + 1
                });
              } else {
                // Remove segment from selection
                const index = selectedSegments.indexOf(name);
                selectedSegments.splice(index, 1);
                this.setStyle(this.originalStyle);
              }
              updateRouteListAndDescription();
            });
          }

          // Fit map to show all route segments
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [20, 20] });
          }

        } catch (error) {
          document.getElementById('error-message').style.display = 'block';
          document.getElementById('error-message').textContent = 'Error parsing KML file: ' + error.message;
        }
      };

      reader.readAsText(file);
    });

    function updateRouteListAndDescription() {
      const routeList = document.getElementById('route-list');
      const routeDescription = document.getElementById('route-description');
      const downloadButton = document.getElementById('download-gpx');

      if (selectedSegments.length === 0) {
        routeList.innerHTML = '<p style="color: #666; font-style: italic;">No segments selected. Click on route segments on the map to add them to your route.</p>';
        routeDescription.textContent = 'Click on map segments to build your route.';
        downloadButton.disabled = true;
        return;
      }

      routeList.innerHTML = '';
      selectedSegments.forEach((segmentName, index) => {
        const segmentDiv = document.createElement('div');
        segmentDiv.className = 'segment-item';
        segmentDiv.innerHTML = `
          <span><strong>${index + 1}.</strong> ${segmentName}</span>
          <button class="remove-btn" onclick="removeSegment('${segmentName}')">Remove</button>
        `;
        routeList.appendChild(segmentDiv);
      });

      routeDescription.innerHTML = `
        <strong>Route Summary:</strong><br>
        ${selectedSegments.length} segment${selectedSegments.length > 1 ? 's' : ''} selected<br>
        <small style="color: #666;">${selectedSegments.join(' → ')}</small>
      `;
      
      downloadButton.disabled = false;
    }

    function removeSegment(segmentName) {
      const index = selectedSegments.indexOf(segmentName);
      if (index > -1) {
        selectedSegments.splice(index, 1);
        
        // Reset polyline to original style
        const polyline = routePolylines.find(p => p.segmentName === segmentName);
        if (polyline) {
          polyline.setStyle(polyline.originalStyle);
        }
        
        updateRouteListAndDescription();
      }
    }

    document.getElementById('download-gpx').addEventListener('click', () => {
      const kmlFile = document.getElementById('kml-file').files[0];
      if (!kmlFile) return;

      const reader = new FileReader();

      reader.onload = (e) => {
        const kmlData = e.target.result;
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlData, 'application/xml');
        const placemarks = kml.getElementsByTagName('Placemark');

        let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="BikeRoutePlanner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <trk>
    <name>Planned Bike Route</name>
    <trkseg>`;

        selectedSegments.forEach(segmentName => {
          for (const placemark of placemarks) {
            const nameElement = placemark.getElementsByTagName('name')[0];
            if (nameElement && nameElement.textContent === segmentName) {
              const coordinatesElement = placemark.getElementsByTagName('coordinates')[0];
              if (coordinatesElement) {
                const coordinatesStr = coordinatesElement.textContent.trim();
                const coordinates = coordinatesStr.split(/\s+/);
                coordinates.forEach(coordStr => {
                  const [lng, lat] = coordStr.split(',');
                  gpx += `
      <trkpt lat="${lat}" lon="${lng}"></trkpt>`;
                });
              }
            }
          }
        });

        gpx += `
    </trkseg>
  </trk>
</gpx>`;

        const blob = new Blob([gpx], {type: 'application/gpx+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'bike_route.gpx';
        a.click();
        URL.revokeObjectURL(url);
      };

      reader.readAsText(kmlFile);
    });

    // Search functionality
    function searchLocation() {
      const searchInput = document.getElementById('location-search');
      const searchError = document.getElementById('search-error');
      const query = searchInput.value.trim();
      
      if (!query) {
        searchError.textContent = 'Please enter a location to search';
        searchError.style.display = 'block';
        return;
      }
      
      searchError.style.display = 'none';
      
      // Use Nominatim (OpenStreetMap) geocoding service
      const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;
      
      fetch(geocodeUrl)
        .then(response => response.json())
        .then(data => {
          if (data && data.length > 0) {
            const result = data[0];
            const lat = parseFloat(result.lat);
            const lon = parseFloat(result.lon);
            
            // Center map on the found location
            map.setView([lat, lon], 13);
            
            // Add a temporary marker to show the searched location
            const marker = L.marker([lat, lon]).addTo(map);
            marker.bindPopup(`<strong>${result.display_name}</strong>`).openPopup();
            
            // Remove the marker after 5 seconds
            setTimeout(() => {
              map.removeLayer(marker);
            }, 5000);
            
            searchInput.value = '';
          } else {
            searchError.textContent = 'Location not found. Please try a different search term.';
            searchError.style.display = 'block';
          }
        })
        .catch(error => {
          console.error('Search error:', error);
          searchError.textContent = 'Error searching for location. Please try again.';
          searchError.style.display = 'block';
        });
    }
    
    // Add event listeners for search
    document.getElementById('search-btn').addEventListener('click', searchLocation);
    document.getElementById('location-search').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        searchLocation();
      }
    });

    // Initialize the map when page loads
    initMap();
  </script>
</body>
</html>
